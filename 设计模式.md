# 面向对象的设计原则

## 单一职责原则

**一个类只负责一个功能领域中的相应职责。引起一个类个改变的与原因只有一个**



# 构造性模式

## 工厂模式


工厂模式是为了将对象的**创建和使用进行分离** ，使用者不需要关注对象的创建和初始化的细节，只需要关注如何使用该对象。

下面以创建日志库为例，需要为用户提供两种日志服务：DatabaseLogger 和 FileLogger。数据库日志服务使用前需要初始化数据库连接，文件日志服务需要初始化文件的创建。

### 简单工厂模式

将 DatabaseLogger 和 FileLogger 抽象成两个类，公共部分抽象成一个接口。然后提供一个工厂类负责对象的创建和初始化。


![输入图片说明](https://raw.githubusercontent.com/GTianLuo/-/master/imgs/30CkAqjt2cXB3z87.png)

**优点**

1. 将对象的创建和使用进行职责分离，用户只需要使用，降低了代码耦合度。当创建或者使用逻辑更改时，只需要改动部分代码。
2. 可以通过引入配置文件的方式，在不更改用户代码的情况下，更换使用的日志库。

**缺点**

1. 当一工厂集中了所有日志库的创建逻辑，职责过重。
2. 不易于扩展，当增加其他日志库时，需要更改Factory中的逻辑代码。

### 工厂方法模式

简单工厂模式只提供了一个工厂类，这个工厂类负责每一个产品对象的创建，耦合度很高。

工厂方法模式就是将原先单一工厂的if-else逻辑使用多态替换掉（对原先单一的工厂进行抽象和拆分）。首先抽象出一个工厂接口来声明抽象工厂方法，由其子类具体实现工厂方法，创建具体的产品对象。

![输入图片说明](https://raw.githubusercontent.com/GTianLuo/-/master/imgs/fnqceslyKstx3PLs.png)

**代码实现**

```go
type LoggerFactory interface {  
   CreateLogger() *logger.Logger  
}  
  
type DatabaseLoggerFactory struct {  
}  
  
func (d *DatabaseLoggerFactory) CreateLogger() logger.Logger {  
   fmt.Println(" init databases connection")  
   return &logger.DatabaseLogger{}  
}  
  
type FileLoggerFactory struct {  
}  
  
func (f *FileLoggerFactory) CreateLogger() logger.Logger {  
   // 初始化环境配置  
   fmt.Println("init file")  
   // 创建对象  
   return &logger.FileLogger{}  
}



// 客户端使用
func main() {  
   f := &loggerFactory.FileLoggerFactory{}  
   logger := f.CreateLogger()  
   logger.WriteLog("hello")  
}
```


**优点**

1. 在系统中增加新的产品时无需更改用户代码和原先的工厂代码，只需要增加一个新的实现了工厂接口的工厂类。扩展线非常好，符合开闭原则。

**缺点**

1. 每增加一个产品类，都需要新增一个工厂类，增加了系统复杂性。

### 抽象工厂模式


为了解决每增加一个产品类。就需要编写新的具体工厂类的问题，我们需要使用抽象工厂模式。**将产品进行了抽象分组。**

不但**工厂是抽象的，产品也是是抽象的**。我们**将产品抽象为不同的组**，一组产品一个工厂，一组内产品对应同组内不同的工厂。

这样原先一个工厂只能生产一个产品类，抽象工厂模式一个工厂可以生产一组同类型的产品。



**特点**

在开闭原则上作出了一定的倾斜性，在增加一个新的产品组时符合开闭原则，但是增加已有组的新产品时需要修改代码。

## 原型模式

使用原型对象，创建一个重复的对象。说简单点就是将原型对象克隆一份。这里又会分浅克隆和深克隆。

**浅克隆**

只会将原型对象的值类型成员变量复制一份给克隆对象，指针类型的成员变量会复制地址给克隆对象。

**深拷贝**
就算遇到指针类型，也要将指针指向的内容拷贝一份。


**使用场景**
1. 新对象要复用原型对象的一些成员变量，比如说C语言Fork子进程，要复用父进程的变量。
2. 可以结合**Copy On Write**技术节省内存。



# 结构性模式



## 外观模式

外部系统需要与一系列子系统进行交互(高耦合)，更改任意一个子系统都需要更改外部系统的代码。外观模式引入了外观角色，通过调用各个子系统，为外部系统提供简单易调用的API接口，外部系统不再需要直接与子系统交互，直接调用外观角色提供的API即可。



**例子**

一个客户端需要完成加密工作，加密分别需要调用三个类，``FileReader(文件读取类)`` ，``CipherMachine(数据加密类)``，``FileWrite(文件写入类)`` 。在引入外观角色前，每一个需要完成加密工作的客户端都需要调用这三个类，当任意一一个子系统修改时，就需要修改所有的客户端。引入一个外观角色后，将原先多客户端与子系统的高耦合变成了当一外观角色和子系统的高耦合。



![image-20230801211744365](/home/gtl/.config/Typora/typora-user-images/image-20230801211744365.png)





**优化**

可以为外观角色抽象出一个外观角色的接口，降低外观角色和子系统之间的耦合度。



**优点**

1. 对外观角色屏蔽了子系统，降低耦合度的同时，也方便了客户端的调用，更好的复用代码

































